import { join, relative } from 'path';
import fs from 'fs';
import { scanDirectory } from './utils.js';

interface IRouteContext {}

const PAGE_FILE_EXTENSION = /(\/index)?.(jsx?|tsx?)$/;

export default class RouteContext {
  private currentDir: string;
  private absSrcPath: string;
  private absPagesPath: string;
  private fileWritePath: string;
  private fileListCache: null | string[]; // 缓存文件列表
  private fileUsedPath: string; // 用户指定的文件路径

  constructor(fileUsedPath: string) {
    const currentDir = process.cwd(); // 当前工作目录
    const absSrcPath = join(currentDir, 'src'); // 源码目录
    const absPagesPath = join(absSrcPath, 'pages'); // 页面目录
    const fileWritePath = join(
      currentDir,
      'node_modules/.farm/virtual_routes.tsx'
    );

    this.currentDir = currentDir;
    this.absSrcPath = absSrcPath;
    this.absPagesPath = absPagesPath;
    this.fileWritePath = fileWritePath;
    this.fileListCache = null;
    this.fileUsedPath = fileUsedPath;
  }

  getFilePathList(dir: string): string[] {
    if (this.fileListCache) {
      return this.fileListCache;
    }

    const PAGE_FILE_REGEX = /\.(jsx?|tsx?)$/; // 匹配 .js, .jsx, .ts, .tsx
    const TYPE_FILE_REGEX = /\.d\.ts$/; // 排除类型声明文件
    const filePathList = scanDirectory(dir).filter((path) => {
      return PAGE_FILE_REGEX.test(path) && !TYPE_FILE_REGEX.test(path);
    });

    return filePathList;
  }

  getContent() {
    const pagePathList = this.getFilePathList(this.absPagesPath);
    const { routesString, routeComponentsString } = this.pathToRoutes(
      pagePathList,
      this.absPagesPath,
      this.fileUsedPath
    );
    const content = [
      '// @ts-nocheck',
      '// this file is generated by farm-plugin-auto-routes',
      '// do not change anytime!',
      `import React, { Suspense } from 'react';`,
      '',
      'function withLazyLoad(LazyComponent) {',
      '  const lazyComponentWrapper = (props) => (',
      '    <Suspense fallback={props.loadingComponent}>',
      '      <LazyComponent {...props} />',
      '    </Suspense>',
      '  );',
      '  return lazyComponentWrapper;',
      '}',
      '',
      'export function getRoutes() {',
      `  const routes = {${routesString}};`,
      '  return {',
      '    routes,',
      '    routeComponents: {',
      `${routeComponentsString}`,
      '    },',
      '  };',
      '}',
      '',
    ];

    try {
      fs.writeFileSync(this.fileWritePath, content.join('\n'));
    } catch (error) {
      console.log(error, 'error');
    }

    return content.join('\n');
  }

  pathToRoutes(
    paths: string[],
    prefix: string,
    fileUsedPath: string
  ): { routesString: string; routeComponentsString: string } {
    const { routes, routeComponents } = paths.reduce(
      (acc, cur) => {
        const routePath = this.normalizePath(cur, prefix, PAGE_FILE_EXTENSION);
        const routeId = routePath.replace(/\//g, '-') || 'index';
        const metaData = {
          ...this.getPageMeta(cur),
          id: routeId,
          path: `/${routePath.replace('$', ':')}`,
        };
        const routeList: string[] = [];
        Object.keys(metaData).forEach((key) => {
          const value = typeof metaData[key] === 'string' ? `'${metaData[key]}'` : metaData[key];
          routeList.push(`'${key}':${value}`);
        });
        acc.routes.push(`'${routeId}':{${routeList.join(',')}}`);
        const relativePath = relative(fileUsedPath, cur);
        acc.routeComponents.push(
          `      '${routeId}': withLazyLoad(React.lazy(() => import('${relativePath}')))`
        );
        return acc;
      },
      { routes: [], routeComponents: [] } as {
        routes: string[];
        routeComponents: string[];
      }
    );

    return {
      routesString: routes.join(','),
      routeComponentsString: routeComponents.join(',\n'),
    };
  }

  getPageMeta(path: string) {
    const metaPath = path.replace(/(tsx?|jsx?)/g, 'meta.json');
    if (fs.existsSync(metaPath)) {
      try {
        return JSON.parse(fs.readFileSync(metaPath, 'utf-8'));
      } catch (error) {
        return {};
      }
    }
    return {};
  }

  normalizePath(path: string, basePath: string, extension: RegExp) {
    return path
      .replace(basePath, '')
      .replace('/\\/g', '')
      .replace(extension, '')
      .slice(1);
  }
}
